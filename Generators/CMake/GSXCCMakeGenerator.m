// Released under the terms of LGPL 2.1, Please see COPYING.LIB

#import "GSXCCMakeGenerator.h"
#import "PBXNativeTarget.h"
#import "XCConfigurationList.h"
#import "PBXBuildFile.h"
#import "PBXFileReference.h"
#import "NSString+PBXAdditions.h"

@implementation GSXCCMakeGenerator

- (instancetype) init
{
  self = [super init];

  if (self != nil)
    {
      _append = NO;
    }
  
  return self;
}

- (NSString *) cmakePreamble: (NSString *)appName
{
  NSString *output = @"";
  NSString *header = [NSString stringWithFormat: @"## CMake Generated by buildtool - %@\n\n", appName];
  NSString *project = [NSString stringWithFormat: @"project(%@ C CXX)\n", appName];
  NSString *ccompiler = [NSString stringForCommand: @"gnustep-config --variable=CC"];
  NSString *cxxcompiler = [NSString stringForCommand: @"gnustep-config --variable=CXX"];
  
  output = [output stringByAppendingString: header];
  output = [output stringByAppendingString: @"## Begin header\n"];
  output = [output stringByAppendingString: @"cmake_minimum_required(VERSION 3.13)\n"];
  output = [output stringByAppendingString: @"set(CMAKE_EXPORT_COMPILE_COMMANDS ON)\n"];
  output = [output stringByAppendingString: @"set(CMAKE_CXX_STANDARD 11)\n"];
  output = [output stringByAppendingString: [NSString stringWithFormat: @"set(CMAKE_C_COMPILER \"%@\")\n", ccompiler]]; // These should be set dynamically...
  output = [output stringByAppendingString: [NSString stringWithFormat: @"set(CMAKE_CXX_COMPILER \"%@\")\n", cxxcompiler]]; // So should this one...
  output = [output stringByAppendingString: project];
  output = [output stringByAppendingString: @"set(BUILD_FOLDER_NAME \"build\")\n"];
  output = [output stringByAppendingString: @"set(CMAKE_SOURCE_DIR \".\")\n\n"];

  return output;
}

- (NSString *) cmakeSourceFiles: (NSArray *)array
{
  NSString *output = @"";
  NSEnumerator *en = [array objectEnumerator];
  NSString *file = nil;
  
  if ([array count] > 0)
    {
      output = [output stringByAppendingString: @"# Begin sources\n"];

      if (_append == NO)
	{
	  output = [output stringByAppendingString: @"set (SOURCES\n"];
	  _append = YES;
	}
      else
	{
	  output = [output stringByAppendingString: @"list (APPEND SOURCES\n"];
	}
    }
  
  while((file = [en nextObject]) != nil)
    {
      output = [output stringByAppendingString: [NSString stringWithFormat: @"  ${CMAKE_SOURCE_DIR}/%@\n", file]];
    }

  if ([array count] > 0)
    {
      output = [output stringByAppendingString: @")\n\n"];
    }
  
  return output;
}

- (NSString *) cmakeHeaderFiles: (NSArray *)array
{
  NSString *output = @"";
  NSEnumerator *en = [array objectEnumerator];
  NSString *file = nil;
  
  if ([array count] > 0)
    {
      output = [output stringByAppendingString: @"# Begin headers\n"];
      output = [output stringByAppendingString: @"set (HEADERS\n"];
    }
  
  while((file = [en nextObject]) != nil)
    {
      output = [output stringByAppendingString: [NSString stringWithFormat: @"  ${CMAKE_SOURCE_DIR}/%@\n", file]];
    }

  if ([array count] > 0)
    {
      output = [output stringByAppendingString: @")\n\n"];
    }
  
  return output;
}

- (NSString *) cmakeLibraryFiles: (NSArray *)array projectType: (NSString *)projType
{
  NSString *output = @"";

  if ([projType isEqualToString: @"application"])
    {
    }
  else if ([projType isEqualToString: @"bundle"])
    {
    }
  else if ([projType isEqualToString: @"library"])
    {
    }
  else if ([projType isEqualToString: @"tool"])
    {
    }

  return output;  
}

- (NSString *) cmakeResourceFiles: (NSArray *)array
{
  NSString *output = @"";
  NSEnumerator *en = [array objectEnumerator];
  NSString *file = nil;
  
  if ([array count] > 0)
    {
      output = [output stringByAppendingString: @"# Begin resources\n"];
      output = [output stringByAppendingString: @"set (GLOBAL_RESOURCES\n"];
    }
  
  while((file = [en nextObject]) != nil)
    {
      output = [output stringByAppendingString: [NSString stringWithFormat: @"  ${CMAKE_SOURCE_DIR}/%@\n", file]];
    }

  if ([array count] > 0)
    {
      output = [output stringByAppendingString: @")\n\n"];
    }
  
  return output;
}

- (NSString *) cmakeProjectType: (NSString *)projType
			   name: (NSString *)appName
{
  NSString *output = @"";

  if ([projType isEqualToString: @"application"])
    {
    }
  else if ([projType isEqualToString: @"bundle"])
    {
    }
  else if ([projType isEqualToString: @"library"])
    {
    }
  else if ([projType isEqualToString: @"tool"])
    {
    }

  return output;
}

- (NSString *) cmakeIncludeDirsName: (NSString *)appName
		     includeDirList: (NSArray *)includeArray
{
  NSString *output = [NSString stringWithFormat: @"# Include directories\ntarget_include_directories(%@ PRIVATE\n", appName];
  NSEnumerator *en = [includeArray objectEnumerator];
  NSString *includeDir = nil;

  while ((includeDir = [en nextObject]) != nil)
    {
      output = [output stringByAppendingString: [NSString stringWithFormat: @"  %@\n", includeDir]];
    }

  // Add canonical directories...
  NSString *localIncludes = [NSString stringForCommand: @"gnustep-config --variable=GNUSTEP_LOCAL_HEADERS"];
  output = [output stringByAppendingString: [NSString stringWithFormat: @"  %@\n", localIncludes]];
  
  NSString *systemIncludes = [NSString stringForCommand: @"gnustep-config --variable=GNUSTEP_SYSTEM_HEADERS"];
  output = [output stringByAppendingString: [NSString stringWithFormat: @"  %@\n", systemIncludes]];

  // Close declaration...
  output = [output stringByAppendingString: @")\n\n"];
  
  return output;
}

- (NSString *) cmakeTargetCompileOptions: (NSString *)appName
{
  NSString *output = [NSString stringWithFormat: @"# Compile options\ntarget_compile_options(%@ PRIVATE ", appName];
  NSString *command = [NSString stringForCommand: @"gnustep-config --objc-flags"];

  output = [output stringByAppendingString: command];
  output = [output stringByAppendingString: @")\n\n"];
  
  return output;
}

- (NSString *) cmakeTargetLinkOptions: (NSString *)appName
{
  NSString *output = [NSString stringWithFormat: @"# Link options\ntarget_link_options(%@ PRIVATE ", appName];
  NSString *command = [NSString stringForCommand: @"gnustep-config --gui-libs"];

  output = [output stringByAppendingString: command];
  output = [output stringByAppendingString: @")\n\n"];
  
  return output;
}

- (NSString *) cmakeDeclareTarget: (NSString *)appName
{
  NSString *output = @"";

  output = [output stringByAppendingString:
		     [NSString stringWithFormat:
				 @"add_executable(\n"
			       @"  %@\n"
			       @"  ${SOURCES}\n"
			       @")", appName]];

  return output;
}

- (BOOL) generate
{
  BOOL result = YES;
  GSXCBuildContext *context = [GSXCBuildContext sharedBuildContext];
  NSString *projectType = [context objectForKey: @"PROJECT_TYPE"];
  NSString *name = [_target name];
  NSString *appName = [name stringByDeletingPathExtension];
  NSString *outputName = @"CMakeLists.txt";
  NSString *outputString = @"";

  // Construct the makefile out of the data we have thusfar collected.
  xcputs("\t* Generating CMakeLists.txt...");

  // Sometimes the build will generate all of the target makefiles in one place,
  // depending on the version of Xcode the project was created with.
  if([[NSFileManager defaultManager] fileExistsAtPath: @"CMakeLists.txt"])
    {
      // if it collides with the existing name, add the target name...
      outputName = [outputName stringByAppendingString: [NSString stringWithFormat: @"_%@.txt", appName]];
    }

  // Initial setup...
  outputString = [self cmakePreamble: appName];

  // Add sources...
  outputString = [outputString stringByAppendingString:
                                [self cmakeSourceFiles: [context objectForKey: @"OBJC_FILES"]]];
  outputString = [outputString stringByAppendingString:
                                [self cmakeSourceFiles: [context objectForKey: @"C_FILES"]]];
  outputString = [outputString stringByAppendingString:
                                [self cmakeSourceFiles: [context objectForKey: @"CPP_FILES"]]];
  outputString = [outputString stringByAppendingString:
                                [self cmakeSourceFiles: [context objectForKey: @"OBJCPP_FILES"]]];
  
  // Declare target
  outputString = [outputString stringByAppendingString:
			      [self cmakeDeclareTarget: appName]];

  // Headers
  outputString = [outputString stringByAppendingString:
				[self cmakeHeaderFiles: [context objectForKey: @"HEADERS"]]];

  outputString = [outputString stringByAppendingString:
			       [self cmakeLibraryFiles: [context objectForKey: @"ADDITIONAL_OBJC_LIBS"]
					   projectType: projectType]];
  // Include dirs
  outputString = [outputString stringByAppendingString:
			    [self cmakeIncludeDirsName: appName
					includeDirList: nil]];
  
  // Resources
  outputString = [outputString stringByAppendingString:
			      [self cmakeResourceFiles: [context objectForKey: @"RESOURCES"]]];

  // Compile options...
  outputString = [outputString stringByAppendingString:
		       [self cmakeTargetCompileOptions: appName]];

  // Link options...
  outputString = [outputString stringByAppendingString:
			  [self cmakeTargetLinkOptions: appName]];
  
  // Handle project type... this builds the directory structure needed for a given type.
  outputString = [outputString stringByAppendingString:
				[self cmakeProjectType: projectType
						  name: appName]];
  
  
  NSDebugLog(@"output = %@", outputString);
  [outputString writeToFile: outputName atomically: YES];
  xcputs([[NSString stringWithFormat: @"=== Completed generation for target %@", name] cString]);

  return result; 
}

@end
